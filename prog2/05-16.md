 # PROG2 - 16-04

## Variabili di tipo puntatore a funzione

le funzioni, come i dati, sono rappresentate in memoria come una sequenza di byte in una porzione di memoria indicata da un certo indirizzo. In c queste
variabili seguono la sintassi seguente: 

diciamo che abbiamo la funzione 
```` 
    int ciao(int n1, int n2){
        retur 1;
    }
````
\può essere puntata da un puntatore creato come:
```` 
    int (*p1)(int, int);
````
Al posto di int si può usare qualunque altro tipo, compreso *void*, e le parentesi degli argomenti possono anche essere vuote.
## Esempi:
```` 
    int res;
    res = (*puntfz)(2, 3);i
````

```` 
    void ciao(){
        printf("ciao");
    }

    void main(){
        void(*test)() = ciao;
        test = ciao;
        (*test)(); //equivale ad una chiamata a ciao
    }
````
\
## Utilizzi

Nei sistemi operativi, tutti i segnali vegono chiamati **interrupt**. Quando arriva un segnale, il SO deve trovare la funzione
giusta per gestire quel segnale. Queste funzioni sono contenute in un vettore chiamato **vettore degli interrupt**. Il seguente esempio
si basa su questa situazione.

````
    int raddoppia(int x){return x*2;}
   ; 
    int per10(int x){return x*10;}
    
    int print (int x){
        printf("%d", x);
        return x;
    }

    int incrementa(int x){return x;}

    int main(){
        int (*handler[4])(int); //array di puntatori a funzioni
        int scelta;
        
        //inizializza il vettore handler
        handler[0] = raddoppia;
        handler[1] = per10;
        handler[2] = print;
        handler[3] = incrementa;

        printf("quale impostazione vuoi?\n1.raddoppia\n2.per10\n3.print\n4.incrementa\n");
        scanf("%d", &scelta);

        x = handler[scelta-1](2);
    }
````

Il codice seguente è utile se vogliamo avere operazioni custom che possono ritornare qualunque tipo;
````
    typedef void*(*opread); // e uguale per le altre op
    typedef struct nodo *albero;
    struct nodo{
        void* dato;
        opcread creadato;
        opstampa stampa;
        opconfronta contronta;
        tree left, right;
    }

    albero t = (albero)malloc(sizeof(struct nodo));
    //i love sucking big throbbing cocks all day and night because i'm fucking gayi
    t->creadato = crea; //nomi di funzioni e/o puntatori a funzioni compatibili
    t->stampa = stampa;
    //ecc...
    t->left = t-> right = NULL;
````


