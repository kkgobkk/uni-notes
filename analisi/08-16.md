# Analisi Matematica 16-08-2025

## Simboli di Landau

**Problema**: date due successioni {an} e {bn}, entrambe divergenti (il loro limite per n->inf = inf).
Vogliamo capire quale delle due "tende a infinito" più velocemente. 

Per confrontare la crescita delle due successioni consideriamo il rapporto {an}/{bn}.

(che è ben definito se n è grande, perché {bn}->+inf => bn>0 definitivamente per n->inf).ù

Otteniamo che:

    (1) lim(n->+inf) {an}/{bn} = 0 => {an} cresce più lentamente di {bn}
    (2) lim(n->+inf) {an}/{bn} = +inf => {an} cresce più velocemente di {bn}
    (3) lim(n->+inf) {an}/{bn} = l in (0, +inf) => {an} cresce "alla stessa velocità" di {bn}

Per sintetizzare informazioni sulla crescita delle successioni, si usano i **simboli di Landau**:

    - {an} è o-piccolo di {bn} <=> an = o(bn) <=> lim(n->+inf) an/bn = 0
    - {an} è o-grande di {bn} <=> an = O(bn) <=> esiste C>0 tc |an/bn| <= C definitivamente per n->+inf
    - {an} è theta-grande di {bn} <=> an = Θ(bn) <=> esistono c, C > 0 tc c <= |an/bn| <= C definitivamente per n->+inf
    - {an} è equivalente di {bn} <=> an ~ bn <=> lim(n->+inf) an/bn = 1

In pratica:
    
    - an = o(bn) <=> {an} cresce più lentamente di {bn}
    - an = O(bn) <=> {an} cresce "non più velocemente" di {bn}
    - an =  Θ(bn) <=> {an} cresce "non più velocemente e non più lentamente" di {bn}
    - an ~ bn <=> {an} e {bn} non solo crescono alla stessa velocità, ma diventano sempre più simili per n->+inf

**Esempio di utilizzo dei simboli di Landau: complessità degli algoritmi**

Confrontiamo due algoritmi di ricerca di un numero k all'interno di un array **ordinato** di lunghezza n

    (1) ricerca sequenziale (o lineare, o esaustiva): scorro il vettore finché a[i] = k, a[i]>k, o il vettore finisce.
    Nel caso peggiore, in cui k non è presente in a e k> a[i] perogni i < n; eseguiamo n confronti. Quindi an nel caso peggiore è uguale a n,
    quindi, an = O(n)

    (2) ricerca dicotomica (o binaria): confronto k con l = a[n/2], se l>k, ripetiamo il procedimento con a1 = a[0, n\2], se invece l<k,
    ripetiamo il procedimento con a2 = a[n/2, n]. In questo caso, il numero massimo di confornti nel caso peggiore (k non appartiene ad a)
    è log2(n), cioè an = O(log2(n))

Quindi, se n è grande, l'algoritmo di ricerca dicotomica è più efficiente rispetto alla ricerca sequenziale.

