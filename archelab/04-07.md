# ArchElab 07-04

## Sequenza di passi per la traduzione da C
* **Inizio**: Programma C
* **Compilazione** -> Programma in linguaggio assembly
* **Assembler** -> Programma in linguaggio macchina + librerie
* **Linker** -> Programma eseguibile
* **Loader** -> Processo in memoria

## Esempio
**livello 4 (sorgente C)**
``` C
void scambia(size_t v[], size_t k){
	size_t temp;
	temp = v[k];
	v[k] = v[k+1];
	v[k+1] = temp;
}
```

**Livello 3 (Assembly RISC-V)**
``` asm
scambia:
	slli a1, a2, 2
	add a5, a0, a1
	lw a4, 0(a5)
	addi a1, a1, 4
	add a0, a0, a1
	lw a3, 0(a0)
	sw a3, 0(a5)
	sw a4, 0(a0)
	ret
``` 

## Ottimizzazioni del compilatore
Il compilatore può usare diversi livelli di ottimizazzione durante la fase di compilazione. Durante la fase di assemblaggio alcune istruzioni RISC-V possono essere sostiutite con versioni ridotte (usando un estensione dell' ISA). Ad esempio, istruzioni che richiedono normalmente delle word possono essere sostiute da altre che richiedono soltanto delle half-word.

## Esecuzione su architetture diverse
Un programma binario con istruzioni in una certa ISA non può essere esguito su una macchina di un altra architettura, ma è possibile tradurre il codice da un'architettura ad un'altra usando un emulatore.
Altri linguaggi, come Java o Python, non vengono compilati, ma **interpretati**: i programmi in questi linguaggi non vengono tradotti per intero ma istruzione per istruzione durante l'esecuzione.

Ad esempio per Java:
* **Inizio**: Programma Java
* **Compilatore** -> FIle delle classi in bytecode, funzioni di libreria (linguaggio macchina)
* **Java Virtual Machine** -> Esegue i metodi in bytecode*

Soltanto la JVM dipende dall'architettura della macchina, per cui lo stesso programma java funziona su tutte le architetture (ma richiedono di installare la JVM prima di poter essere interpretati)

Lo svantaggio di questo approccio è che intepretare le singole istruzioni una per una è molto più costoso per il processore rispetto ad eseguire un programma precompilato. 

* Per ovviare a questo problema, Java utilizza librerie precompilate in linguaggio macchina a seconda dell'architettura di destinazione, e può anche richiamare il compilatore **Just In Time**, che compila i metodi da bytecode a linguaggio macchina (soltanto la prima volta che il programma è eseugito). 

## Differenze tra linguaggio Assembly e macchina
* etichette simboliche per variabili ed indirizzi
* Direttive per l'assemblatore
* pseudo-istruzioni
* costanti
* definizione di macro (esempio: #define in C)

### Macro in Assembly:
``` asm
.swap reg1, reg2, reg3
	add \reg3, \reg3, zero
	add \reg1, \reg2, zero
	add \reg2, \reg3, zero
.endm
```

In linguaggio macchina, questo è semplicemente tradotto sostituendo tutte le chiamate alle macro con le istruzioni al suo interno. (Le macro non sono un sostituto delle funzioni perché se vengono usate spesso rendono il codice macchina molto più grande)

### Direttive dell'Assemblatore
Sono tutte le direttive precedute dal simbolo ' . ' nei programmi assembly (es .globl, .text, .data, ecc...)

## Traduzione di salti
Le istruzioni in C che richiedono slait, quelle di selezione e iterazione sono tradotti dall'assembler con delle istruzioni di salti a label: ma le label non esistono in linguaggio macchina.

Durante la traduzione, queste label devono essere sostituite con valori numerici associati alla posizione della label nel programma (**ILC: Instruction Location Counter**).

Siccome le label possono anche trovarsi dopo delle istruzioni in cui sono utilizzate (forward reference), la tabella ICL deve essere creata *prima* della fase di assemblaggio vera e propria: prima l'assembler legge tutto il programma e prepara la ICL, poi avviene la traduzione vera e propria.

I valori delle ICL sono salvate in una tabella chiamata **Symbol Table**

**Esempio: **
``` asm
...
bgt a2, a3, .L20
...
```

|          SIMBOLO          |         VALORE ICL           |               altro...     |
|--------------------|--------------------|--------------------|
|           .L20         |0x462                   |...                    |

L'istruzione, assumendo che si trovi all'indirizzo 0x43a, verrà tradotta con:

``` asm
...
bgt a2, a3, 0x28
...
```

perché 0x462 - 0x43a = 1122 - 1082 = 40 = 0x28

