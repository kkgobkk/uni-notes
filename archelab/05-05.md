# Archelab 05-05
## Circuito combinatorio : decoder
input: n bus 

output: 2^n bus

## Multiplexer
vedere sldie lol

## Addizionatori

Ricevono in input 2 cifre da sommare e un carryIn, ritorna come output la somma a + b e un carryOut.

Es: (0, 1, 1) -> (1, 0)

**Tabella di verità**

|a         |b         | carryIn        | sum        | carryout|    
|---------|---------|---------|---------|---------|
|        0 |       0  |     0    |     0    |    0     |         
|    0     |        0 |      1   |      1   |   0      |         
|      0   |       1  |       0  |       1  |  0       |        
|      0   |        1 |    1     |       0  | 1        |        
|      1   |        0 |     0    |       1  | 0        |        
|       1  |         0|      1   |   0      |1         |        
|       1  | 1       |        0 |   0      |  1       |        
|       1  |  1      |        1 |     1    |  1       |        

sum = (a XOR b) XOR CIn
carryOut = CIn(a XOR b) + ab

## ALU a 1 bit
Dati a e b, è in grado di calcolare:

* a AND b
* a OR b
* a + b (somma aritmetica)

C'è bisogno di un operation bus che dice alla alu quale operazione deve eseguire:

|       operation        |funzione               |
|---------------|---------------|
|        00       |        and       |   
|          01     |      or         |        
|           10    |   add            |
|             11  |???               |


## ALU a 32 bit

sono 32 alu a 1 bit in fila lol
ovviamente il bus operation deve essere uguale per tutte  e 32
il carryin è presente anche nella prima ALU per motivi mistici

## I segnali di invert
Si possono aggiungere alla alu vista in precedenza due bus Ainvert e Binvert che dicono alla ALU se fare l'operaizone con i valori di A e B o con i loro valori negati

per come funziona il complemento a 2, !n + 1 = -n => è possibile eseguire operazioni di sottrazione semplicemente eseguendo una somma, con Binvert a 1 e carryIN a 1.

grazie alle leggi di deMorgan, possiamo anche eseguire operanzioni come nor e nand semplicemente negando entrambi gli input e eseguendo l'operazione opposta

## Operation == 11?
Possiamo sfruttare la combinazione 11 del bus operation per fare la **Set Less Than (SLT)** che da in output 1 <=> a < b <=> (a - b) > 0 <=> il bit del segno = 1 

ovvero basta guardare se il bit meno significativo è uguale a 1
	
## Controllare se a == b
Eseguiamo a - b e controlliamo se il risultato è uguale a 0 mettendo i singoli bit in un nor (ritorna 1 <=> ogni singolo bit è uguale a 0)g

